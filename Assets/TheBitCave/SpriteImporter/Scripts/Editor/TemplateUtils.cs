//----------------------------------------------
//            Sprite Importer
//       Copyright © 2015 Marco Secchi
//           http://thebitcave.com
//----------------------------------------------

using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.Text;

/// <summary>
/// A set of utility methods to manage the templating system
/// </summary>

namespace TheBitCave.SpriteImporter {

	[InitializeOnLoad]
	public class TemplateUtils {

		public const string TheTemplateAssetName = "Template.asset";

		const string TheTemplatesFolderName = "Templates";
		const string TheEditorFolderName = "Scripts/Editor";
		const string TheGeneratedFolderName = "Generated";
		const string TheSpriteImporterFolderPath = "Assets/TheBitCave/SpriteImporter";
		const string TheEditorFolderPath = TheSpriteImporterFolderPath + "/" + TheEditorFolderName;

		const string TheNewFromTemplateMenuItemsFileName = "NewFromTemplateMenuItems.cs";
		const string TheApplyTemplateToSelectionFileName = "ApplyTemplateToSelectionMenuItems.cs";

		internal const string TheTemplatesFolderPath = TheSpriteImporterFolderPath + "/" + TheTemplatesFolderName;
		internal const string TheGeneratedFolderPath = TheEditorFolderPath + "/" + TheGeneratedFolderName;

		/// <summary>
		/// On Editor startup, generates the folder where templates are stored and
		/// the folder where templates are stored. Menu scripts are then refreshed.
		/// </summary>
		static TemplateUtils() {
			if(!AssetDatabase.IsValidFolder(TheTemplatesFolderPath))
				AssetDatabase.CreateFolder(TheSpriteImporterFolderPath, TheTemplatesFolderName);

			if(!AssetDatabase.IsValidFolder(TheGeneratedFolderPath))
				AssetDatabase.CreateFolder(TheEditorFolderPath, TheGeneratedFolderName);
		}

		/// <summary>
		/// Returns a list of available templates in 'Templates' folder
		/// </summary>
		/// <value>The template list.</value>
		internal static string[] TemplateList {
			get {
				List<string> list = new List<string>();

				if(AssetDatabase.IsValidFolder(TheTemplatesFolderPath)) {
					string[] files = System.IO.Directory.GetFiles(TheTemplatesFolderPath);
					SpriteImporterData template;
					foreach(string filePath in files) {
						template = (SpriteImporterData)AssetDatabase.LoadAssetAtPath(filePath, typeof(SpriteImporterData));
						if(template != null) {
							list.Add(template.name);
						}
					}
				}
				return list.ToArray();
			}
		}

		/// <summary>
		/// Copies the template in the currently selected folder
		/// </summary>
		/// <param name="templateName">The selected template name</param>
		/// <param name="targetFolder">The folder where the template will be copied.</param>
		internal static void ApplyTemplate(string templateName, string targetFolder) {
			string templatePath = TheTemplatesFolderPath + "/" + templateName + ".asset";
			string filePath = targetFolder + "/" + SpriteImporterData.TheImporterDataAssetName;

			AssetDatabase.DeleteAsset(filePath);
			AssetDatabase.CopyAsset(templatePath, filePath);
			AssetDatabase.Refresh();

			SpriteImporterData data = (SpriteImporterData)AssetDatabase.LoadAssetAtPath(filePath, typeof(SpriteImporterData));
			Selection.activeObject = data;
			string assetName = "/" + SpriteImporterData.TheImporterDataAssetName;
			string folderPath = AssetDatabase.GetAssetPath(data).Replace(assetName, "");
			AssetDatabase.ImportAsset(folderPath, ImportAssetOptions.ForceUpdate | ImportAssetOptions.ImportRecursive);
		}

		internal static void NewFromTemplate(string templateName, string targetFolder) {
		
			if(AssetDatabase.LoadMainAssetAtPath(targetFolder + "/" + SpriteImporterData.TheImporterDataAssetName) == null) {
				ApplyTemplate(templateName, targetFolder);
			} else {
				if(EditorUtility.DisplayDialog("Sprite Importer Exists",
				                               "A sprite importer already exists in folder " + targetFolder + ". Do you want to overwrite it?",
				                               "Overwrite",
				                               "Cancel")) {
					ApplyTemplate(templateName, targetFolder);
				}
			}
		}

		/// <summary>
		/// Generates a class that creates a list of menu items for
		/// creating new Sprite Improters from templates
		/// </summary>
		internal static void GenerateNewFromTemplatesMenuItemsScript() {
			string dPath = Application.dataPath;
			dPath = dPath.Substring(0, dPath.LastIndexOf("Assets"));
			string scriptFile = dPath + TheEditorFolderPath + "/" + TheGeneratedFolderName + "/" + TheNewFromTemplateMenuItemsFileName;

			StringBuilder sb = new StringBuilder();

			sb.AppendLine("// This class is Auto-Generated by GenerateNewFromTemplatesMenuScript() in TemplateUtils");
			sb.AppendLine("using UnityEngine;");
			sb.AppendLine("using UnityEditor;");
			sb.AppendLine("");
			sb.AppendLine("namespace TheBitCave.SpriteImporter {");
			sb.AppendLine("");
			sb.AppendLine("  public static class NewFromTemplateMenuItems {");
			sb.AppendLine("");
			
			int priority = 701;
			int count = 1;

			if(TemplateList.Length == 0) {
				sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/New Import Settings From Template/No Templates Available\", false, " + priority.ToString() + ")]");
				sb.AppendLine("    private static void NewTemplate() {");
				sb.AppendLine("    }");
				sb.AppendLine("");
				
				sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/New Import Settings From Template/No Templates Available\", true)]");
				sb.AppendLine("    private static bool NewTemplateValidation() {");
				sb.AppendLine("        return false;");
				
				sb.AppendLine("    }");
				sb.AppendLine("");
			} else {
				foreach(string templateName in TemplateList) {
					sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/New Import Settings From Template/" + templateName + "\", false, " + priority.ToString() + ")]");
					sb.AppendLine("    private static void NewTemplate" + count.ToString() + "() {");
					sb.AppendLine("        TemplateUtils.NewFromTemplate(\"" + templateName + "\", AssetDatabase.GetAssetPath(Selection.activeObject));");
					
					sb.AppendLine("    }");
					sb.AppendLine("");
					
					sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/New Import Settings From Template/" + templateName + "\", true)]");
					sb.AppendLine("    private static bool NewTemplate" + count.ToString() + "Validation() {");
					sb.AppendLine("        return AssetDatabase.IsValidFolder(AssetDatabase.GetAssetPath(Selection.activeObject));");
					
					sb.AppendLine("    }");
					sb.AppendLine("");
					
					priority++;
					count++;
				}
			}

			sb.AppendLine("");
			sb.AppendLine("  }");
			sb.AppendLine("}");

			System.IO.File.Delete(scriptFile);
			System.IO.File.WriteAllText(scriptFile, sb.ToString(), System.Text.Encoding.UTF8);
			AssetDatabase.ImportAsset(TheGeneratedFolderPath + "/" + TheNewFromTemplateMenuItemsFileName);
		}

		
		/// <summary>
		/// Generates a class that creates a list of menu items for
		/// applying templates to textures or selections
		/// </summary>
		internal static void GenerateApplyTemplateToSelectionMenuItemsScript() {

			string dPath = Application.dataPath;
			dPath = dPath.Substring(0, dPath.LastIndexOf("Assets"));
			string scriptFile = dPath + TheEditorFolderPath + "/" + TheGeneratedFolderName + "/" + TheApplyTemplateToSelectionFileName;
			
			StringBuilder sb = new StringBuilder();
			
			sb.AppendLine("// This class is Auto-Generated by GenerateNewFromTemplatesMenuScript() in TemplateUtils");
			sb.AppendLine("using UnityEngine;");
			sb.AppendLine("using UnityEditor;");
			sb.AppendLine("");
			sb.AppendLine("namespace TheBitCave.SpriteImporter {");
			sb.AppendLine("");
			sb.AppendLine("  public static class ApplyTemplateToSelectionMenuItems {");
			sb.AppendLine("");
			
			int priority = 752;
			int count = 1;
			
			if(TemplateList.Length == 0) {
				sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/Apply Template To Selection/No Templates Available\", false, " + priority.ToString() + ")]");
				sb.AppendLine("    private static void NewTemplate() {");
				sb.AppendLine("    }");
				sb.AppendLine("");
				
				sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/Apply Template To Selection/No Templates Available\", true)]");
				sb.AppendLine("    private static bool NewTemplateValidation() {");
				sb.AppendLine("        return false;");
				
				sb.AppendLine("    }");
				sb.AppendLine("");
			} else {
				foreach(string templateName in TemplateList) {
					sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/Apply Template To Selection/" + templateName + "\", false, " + priority.ToString() + ")]");
					sb.AppendLine("    private static void NewTemplate" + count.ToString() + "() {");
					sb.AppendLine("        TextureUtils.ApplyTemplateToTextures(Selection.objects, \"" + templateName + "\");");
					
					sb.AppendLine("    }");
					sb.AppendLine("");
					
					sb.AppendLine("    [MenuItem(\"Assets/TBC Sprite Importer/Apply Template To Selection/" + templateName + "\", true)]");
					sb.AppendLine("    private static bool NewTemplate" + count.ToString() + "Validation() {");
					sb.AppendLine("        bool enable = TextureUtils.IncludesAllTextures(Selection.objects);");
					sb.AppendLine("        return enable;");
					
					sb.AppendLine("    }");
					sb.AppendLine("");
					
					priority++;
					count++;
				}
			}
			
			sb.AppendLine("");
			sb.AppendLine("  }");
			sb.AppendLine("}");
			
			System.IO.File.Delete(scriptFile);
			System.IO.File.WriteAllText(scriptFile, sb.ToString(), System.Text.Encoding.UTF8);
			AssetDatabase.ImportAsset(TheGeneratedFolderPath + "/" + TheApplyTemplateToSelectionFileName);
		}

		/// <summary>
		/// Saves the template.
		/// </summary>
		/// <param name="assetPath">The asset path.</param>
		/// <param name="templatePath">The template path.</param>
		/// <param name="deleteBeforeCopying">If set to <c>true</c> delete the existing asset before copying.</param>
		internal static void SaveTemplate(string assetPath, string templatePath, bool deleteBeforeCopying = false) {
			if(deleteBeforeCopying)
				AssetDatabase.DeleteAsset(templatePath);
			AssetDatabase.CopyAsset(assetPath, templatePath);
		}

		/// <summary>
		/// Creates a SpriteImporterData, imports data from the texture and saves it as a template.
		/// </summary>
		/// <param name="textureImporter">The texture importer.</param>
		/// <param name="templatePath">The path of the saved template.</param>
		internal static void GenerateTemplateFromTextureImporter(TextureImporter textureImporter, string templatePath) {
			TextureImporterSettings settings = new TextureImporterSettings();
			textureImporter.ReadTextureSettings(settings);

			SpriteImporterData asset = ScriptableObject.CreateInstance("SpriteImporterData") as SpriteImporterData;
			asset.Init();

			asset.spriteMode = settings.spriteMode;
			asset.pixelsPerUnit = settings.spritePixelsPerUnit;
			asset.spriteAlignment = settings.spriteAlignment;
			asset.spritePivot = settings.spritePivot;
			asset.generateMipMaps = settings.mipmapEnabled;
			asset.filterMode = settings.filterMode;
			asset.maxSize = settings.maxTextureSize;
			asset.textureImporterFormat = settings.textureFormat;
			asset.packingTag = textureImporter.spritePackingTag;
			asset.compressionQuality = textureImporter.compressionQuality;
			asset.overrideSpriteEditorSettings = false;
			
			int maxTextureSize;
			TextureImporterFormat textureImporterFormat;
			int compressionQuality;

			string[] labels = SpriteImporterData.platformLabels;
			for(int i = 1; i < labels.Length; i++) {
				int index = i - 1;
				bool isEnabled = textureImporter.GetPlatformTextureSettings(labels[i], out maxTextureSize, out textureImporterFormat, out compressionQuality);
				if(isEnabled) {
					asset.platformImportDataAr[index].overrideForTargetPlatform = true;
					asset.platformImportDataAr[index].maxSize = maxTextureSize;
					asset.platformImportDataAr[index].textureImporterFormat = textureImporterFormat;
					asset.platformImportDataAr[index].compressionQuality = compressionQuality;
				} else {
					asset.platformImportDataAr[index].overrideForTargetPlatform = false;
				}
			}

			// checks if it is an applicable grid
			if(textureImporter.spritesheet != null && textureImporter.spritesheet.Length > 0 && settings.spriteMode == 2) {
				int width = (int)textureImporter.spritesheet[0].rect.width;
				int height = (int)textureImporter.spritesheet[0].rect.height;
				Vector4 border = textureImporter.spritesheet[0].border;
				Vector2 pivot = textureImporter.spritesheet[0].pivot;
				int alignment = textureImporter.spritesheet[0].alignment;
				bool isGrid = true;
				foreach(SpriteMetaData smd in textureImporter.spritesheet) {
					if(smd.rect.width != width ||
					   smd.rect.height != height ||
					   (int)smd.rect.x % width != 0 ||
					   (int)smd.rect.y % height != 0 ||
					   smd.border.x != border.x ||
					   smd.border.y != border.y ||
					   smd.border.w != border.w ||
					   smd.border.z != border.z ||
					   smd.alignment != alignment ||
					   smd.pivot.x != pivot.x ||
					   smd.pivot.y != pivot.y) {
						isGrid = false;
						break;
					}

					if(isGrid) {
						asset.overrideSpriteEditorSettings = true;
						asset.sliceWidth = width;
						asset.sliceHeight = height;
						asset.sliceBorder = border;
						asset.spritePivot = pivot;
						asset.spriteAlignment = alignment;
					}
				}
			}

			AssetDatabase.CreateAsset(asset, templatePath);
			AssetDatabase.SaveAssets();
			Selection.activeObject = asset;
		}

		/// <summary>
		/// Returns the template data from the template name.
		/// </summary>
		/// <returns>The template data.</returns>
		/// <param name="templateName">The template name.</param>
		internal static SpriteImporterData GetTemplateData(string templateName) {
			return (SpriteImporterData)AssetDatabase.LoadAssetAtPath(TheTemplatesFolderPath + "/" + templateName + ".asset", typeof(SpriteImporterData));
		}

	}
}